--DROP FUNCTION doTest;

CREATE FUNCTION doTest(ie1_ra double precision) RETURNS BOOLEAN as $$
BEGIN
  DECLARE ready BOOLEAN;
  DECLARE intersection BOOLEAN;  
  DECLARE e1_a double precision;
  DECLARE e1_b double precision;
  DECLARE e1_pa double precision;
  DECLARE e2_a double precision;
  DECLARE e2_b double precision;
  DECLARE e2_pa double precision;
  DECLARE theta_rot double precision;
  DECLARE e2_phi double precision;
  DECLARE e1_q1 double precision;
  DECLARE e1_q3 double precision;
  DECLARE e1_q6 double precision;
  DECLARE distance double precision;
  DECLARE e2_h double precision;
  DECLARE e2_k double precision;
  DECLARE e2_h_acc double precision;
  DECLARE e2_k_acc double precision;
  DECLARE e2_q1 double precision;
  DECLARE e2_q2 double precision;
  DECLARE e2_q3 double precision;
  DECLARE e2_q4 double precision;
  DECLARE e2_q5 double precision;
  DECLARE e2_q6 double precision;
  DECLARE v0 double precision;
  DECLARE v1 double precision;
  DECLARE v2 double precision;
  DECLARE v3 double precision;
  DECLARE v4 double precision;
  DECLARE v5 double precision;
  DECLARE v6 double precision;
  DECLARE v7 double precision;
  DECLARE v8 double precision;
  DECLARE alpha0 double precision;
  DECLARE alpha1 double precision;
  DECLARE alpha2 double precision;
  DECLARE alpha3 double precision;
  DECLARE alpha4 double precision;
  DECLARE delta0 double precision;
  DECLARE delta1 double precision;
  DECLARE delta2 double precision;
  DECLARE eta0 double precision;
  DECLARE eta1 double precision;
  DECLARE vartheta0 double precision;
  DECLARE s_f0 INT;
  DECLARE s_f1 INT;
  DECLARE s_f2 INT;
  DECLARE s_f3 INT;
  DECLARE s_f4 INT;
  DECLARE sign_change_neg INT;
  DECLARE sign_change_pos INT;
  DECLARE Nroots INT;

58
59
  SET ready = FALSE;
59
61
  SET intersection = FALSE;
  
  /**
   * We convert from degrees to arcseconds
   */
64
67
/*  SET e1_a = 3600 * GREATEST(ie1_ra_err, ie1_decl_err);
65
69
  SET e1_b = 3600 * LEAST(ie1_ra_err, ie1_decl_err);
  IF ie1_ra_err > ie1_decl_err THEN
67
72
    SET e1_pa = 90;
  ELSE 
69
75
    SET e1_pa = 0;
  END IF;
71
78
  SET e2_a = 3600 * GREATEST(ie2_ra_err, ie2_decl_err);
72
80
  SET e2_b = 3600 * LEAST(ie2_ra_err, ie2_decl_err);
  IF ie2_ra_err > ie2_decl_err THEN
74
83
    SET e2_pa = 90;
  ELSE 
76
86
    SET e2_pa = 0;
  END IF;

79
90
  SET e2_h = 3600 * (ie1_ra - ie2_ra);
80
92
  SET e2_k = 3600 * (ie2_decl - ie1_decl);

82
95
  SET theta_rot = RADIANS(e1_pa - 90);
83
97
  SET e2_phi = RADIANS(e2_pa - e1_pa);

85
100
  SET e2_h_acc =  e2_h * COS(theta_rot) + e2_k * SIN(theta_rot);
86
102
  SET e2_k_acc = -e2_h * SIN(theta_rot) + e2_k * COS(theta_rot);
*/
  /* We drop the _acc suffix */
89
106
/*  SET e2_h = e2_h_acc;
90
108
  SET e2_k = e2_k_acc;
*/
  /** 
   * These tests can be executed immediately, to know
   * whether one there is separation or containment.
   */
96
115
/*  SET distance = SQRT(e2_h * e2_h + e2_k * e2_k);
  IF distance > (e1_a + e2_a) THEN
98
118
    SET intersection = FALSE;
99
120
    SET ready = TRUE;
  END IF;

  IF ready = FALSE THEN
    IF distance <= (e1_b + e2_b) THEN
104
126
      SET intersection = TRUE;
105
128
      SET ready = TRUE;
    END IF;
  END IF;
*/
  /**
   * If the ellipses are to far there is separation and 
   * the ellipses do not intersection.
   * If the ellipses are to close there is intersectionion 
   * and we are done as well.
   * The other cases we have to evaluate.
   */
/*  IF (ready = FALSE) THEN

118
142
    SET e1_q1 = e1_a * e1_a;
119
144
    SET e1_q6 = e1_b * e1_b;
120
146
    SET e1_q3 = -e1_q1 * e1_q6;

122
149
    SET e2_q1 = e2_a * e2_a * COS(e2_phi) * COS(e2_phi) 
                + e2_b * e2_b * SIN(e2_phi) * SIN(e2_phi);
124
152
    SET e2_q6 = e2_a * e2_a * SIN(e2_phi) * SIN(e2_phi)
                + e2_b * e2_b * COS(e2_phi) * COS(e2_phi);
126
155
    SET e2_q4 = (e2_b * e2_b - e2_a * e2_a) * SIN(2 * e2_phi);
127
157
    SET e2_q2 = -2 * e2_k * e2_q1 - e2_h * e2_q4;
128
159
    SET e2_q3 = e2_h * e2_h * e2_q6 + e2_k * e2_k * e2_q1 
                + e2_h * e2_k * e2_q4 - e2_a * e2_a * e2_b * e2_b;
130
162
    SET e2_q5 = -2 * e2_h * e2_q6 - e2_k * e2_q4;

132
165
    SET v0 = e1_q6 * e2_q4;
133
167
    SET v1 = e1_q6 * e2_q1 - e2_q6 * e1_q1;
134
169
    SET v2 = e1_q6 * e2_q5;
135
171
    SET v3 = e1_q6 * e2_q2;
136
173
    SET v4 = e1_q6 * e2_q3 - e2_q6 * e1_q3;
137
175
    SET v5 = -e2_q4 * e1_q1;
138
177
    SET v6 = -e2_q4 * e1_q3;
139
179
    SET v7 = e1_q1 * e2_q5;
140
181
    SET v8 = -e2_q5 * e1_q3;
*/
    /**
     * The coefficients of the Bezout determinant
     */
145
187
/*    SET alpha0 = v2 * v8 - v4 * v4;
146
189
    SET alpha1 = v0 * v8 + v2 * v6 - 2 * v3 * v4;
147
191
    SET alpha2 = v0 * v6 - v2 * v7 - v3 * v3 - 2 * v1 * v4;
148
193
    SET alpha3 = -v0 * v7 + v2 * v5 - 2 * v1 * v3;
149
195
    SET alpha4 = v0 * v5 - v1 * v1;

151
198
    SET alpha0 = alpha0 / alpha4;
152
200
    SET alpha1 = alpha1 / alpha4;
153
202
    SET alpha2 = alpha2 / alpha4;
154
204
    SET alpha3 = alpha3 / alpha4;
155
206
    SET alpha4 = 1;

157
209
    SET delta2 = ((3 * alpha3 * alpha3) / (16 * alpha4)) - (alpha2/2);
158
211
    SET delta1 = ((alpha2 * alpha3) / (8 * alpha4)) - ((3 * alpha1)/4);
159
213
    SET delta0 = (alpha1 * alpha3 / (16 * alpha4)) - alpha0;
160
215
    SET eta1 = (delta1/delta2) * 
               (3 * alpha3 - (4 * (alpha4 * delta1 / delta2))) - 
               (2 * alpha2 - (4 * (alpha4 * delta0 / delta2))); 
163
219
    SET eta0 = (delta0/delta2) * 
               (3 * alpha3 - (4 * (alpha4 * delta1 / delta2))) - 
               (3 * alpha3);
166
223
    SET vartheta0 = (eta0/eta1) * 
                    (delta1 - (eta0 * delta2 / eta1)) - delta0;
*/
    /**
     * Determine sign for -infty
     */
172
230
/*    SET s_f0 = SIGN(alpha4);
173
232
    SET s_f1 = SIGN((-4*alpha4));
174
234
    SET s_f2 = SIGN(delta2);
175
236
    SET s_f3 = SIGN(-eta1);
176
238
    SET s_f4 = SIGN(vartheta0);

178
241
    SET sign_change_neg = 0;
  
    IF s_f0 * s_f1 < 0 THEN
181
245
      SET sign_change_neg = sign_change_neg + 1;
    END IF;
    IF s_f1 * s_f2 < 0 THEN
184
249
      SET sign_change_neg = sign_change_neg + 1;
    END IF;
    IF s_f2 * s_f3 < 0 THEN
187
253
      SET sign_change_neg = sign_change_neg + 1;
    END IF;
    IF s_f3 * s_f4 < 0 THEN
190
257
      SET sign_change_neg = sign_change_neg + 1;
    END IF;
*/
    /**
     * Determine sign for +infty
     */
196
264
/*    SET s_f0 = SIGN(alpha4);
197
266
    SET s_f1 = SIGN((4*alpha4));
198
268
    SET s_f2 = SIGN(delta2);
199
270
    SET s_f3 = SIGN(eta1);
200
272
    SET s_f4 = SIGN(vartheta0);

202
275
    SET sign_change_pos = 0;
  
    IF s_f0 * s_f1 < 0 THEN
205
279
      SET sign_change_pos = sign_change_pos + 1;
    END IF;
    IF s_f1 * s_f2 < 0 THEN
208
283
      SET sign_change_pos = sign_change_pos + 1;
    END IF;
    IF s_f2 * s_f3 < 0 THEN
211
287
      SET sign_change_pos = sign_change_pos + 1;
    END IF;
    IF s_f3 * s_f4 < 0 THEN
214
291
      SET sign_change_pos = sign_change_pos + 1;
    END IF;

217
295
    SET Nroots = sign_change_neg - sign_change_pos;
    IF Nroots > 0 THEN
219
298
      SET intersection = TRUE;
    ELSE
221
301
      SET intersection = FALSE;
    END IF;
  
  END IF; 
*/  
  RETURN intersection;

END;
$$ language plpgsql;
