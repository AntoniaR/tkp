#
# LOFAR Transients Key Project
#
# This code provides a framework for integrating with the "PyMori" classifier
# system.

# Aiming for two things at present:
# 1) A class that can be 'mixed in' to lightcurves to enable easy feature
#    vector calculation.
# 2) A wrapper for the pymori objects to enable us to easily use them from the
#    pipeline.

import numpy
import settings
# import pymori

classDefinitions = ['Test 1',
    'Test 2',
    'Etc']

class FeatureCalculator(object):
    # Contains a series of methods for operating on a lightcurve to calculate
    # quantites which might be used in defining a feature vector (the
    # 'calculator' methods below). Also some admin functionality for helping
    # the lightcurve class interact with the classifier class.
    def __init__(self, classID=None):
        self.objects = []
        # If classID is an integer, assume it's a reference to a position in
        # classDefinitions (if it fits). If it's a string, see if it's a label
        # from classDefinitions. Otherwise, assume it's garbage and ignore.
        if type(classID) == int and classID >= 0 and classID < len(classDefinitions):
            self.classID = classID
        else:
            try:
                self.classID = classDefinitions.index(classID)
            except ValueError:
                self.classID = None
        
    def featureVector(self, features=settings.featureVector):
        # Build list of all requested features.
        vector = [getattr(self, featureName)() for featureName in features]
        # Unique ID: only needed for training. Generated by the classifier
        # class; we just have a placeholder here.
        vector.append(None)
        # Weight: unused.
        vector.append(None)
        # Class ID: only needed for training data. If we're going to use this
        # lightcurve for training, it needs to know what its ID is!
        vector.append(self.classID)
        return vector
    
    # "Calculator" methods below this point.
    def meanFlux(self):
        # Trivial example of the protoypical 'feature calculator' used for
        # building vectors.
        fluxes = numpy.array([])
        for src in self.objects:
            fluxes = numpy.append(fluxes, [det.peak for det in src.objects])
        return numpy.mean(fluxes)

    def peakFlux(self):
        # Another simple example, but useful for other features
        fluxes = numpy.array([])
        for src in self.objects:
            fluxes = numpy.append(fluxes, [det.peak for det in src.objects])
        return fluxes.max()

    def sigmaClip(self):
        # Estimate of bg rms of lightcurve using sigma clipping.  Reduces the
        # array by iteratively removing entries higher than 3sigma from mean.
        fluxes = numpy.array([])
        for src in self.objects:
            fluxes = numpy.append(fluxes, [det.peak for det in src.objects])

        # Define new lightcurve, which will become best guess of background.
        fluxes_clipped = fluxes[numpy.where(fluxes <= fluxes.mean()+3*fluxes.std())]

        # Iteratively clip 3sigma deviations from mean.
        while len(fluxes_clipped) > 2:
            length_fluxes_clipped = len(fluxes_clipped)
            fluxes_clipped = fluxes_clipped[numpy.where(fluxes_clipped <= fluxes.mean()+3*fluxes_clipped.std())]

            # Exit when nothing is getting clipped.
            if length_fluxes_clipped == len(fluxes_clipped):  break

        # Now, in principle, fluxes_clipped is mostly "noise", but this may also
        # include noiselike behavior of sources.
        return fluxes_clipped.std()

    def riseTime(self):
        # Measure of time from start of event to peak flux.  Assumes only one
        # event in lightcurve.
        fluxes = numpy.array([])
        for src in self.objects:
            fluxes = numpy.append(fluxes, [det.peak for det in src.objects])

        # Get peak and clipped sigma of lightcurve.  Is this correct syntax?
        peakFlux = getattr(self, peakFlux)()
        sigmaClip = getattr(self, sigmaClip)()

        # Now find index difference between first 3sigma and peak times.
        start_index = numpy.where(fluxes >= fluxes.mean()+3*sigmaClip)[0][0]
        peak_index = numpy.where(fluxes == peakFlux)[0][0]

        # Need to get this into real time...  How?
        return peak_index - start_index

    def centralFluxTime(self):
        # Measure of duration event as central fraction of integrated flux.
        # Analogous to t90, in GRB (x-ray) observations.
        # Needs adjusting...?  Flux adding may include unrelated 3sigma noise.
        fluxes = numpy.array([])
        for src in self.objects:
            fluxes = numpy.append(fluxes, [det.peak for det in src.objects])

        # Get 3*sigma part of lightcurve.  Is this correct syntax?
        # "Event" defined as all integrations with >3sigma flux
        sigmaClip = getattr(self, sigmaClip)()
        fluxes_high = fluxes[where(fluxes >= fluxes.mean()+3*sigmaClip)]

        # Define size of central fraction of flux
        # i.e., "0.9" means the time is duration of central 90% of flux
        central_fraction = 0.9
        
        # Start at bottom and add flux in 3sigma lightcurve until limit
        bottom_sum = 0
        bottom_index = 0
        while bottom_sum < fluxes_high.sum() * (1-central_fraction)/2.:
            bottom_sum += fluxes_high[bottom_index]
            bottom_index += 1

        # Start at top and add flux in 3sigma lightcurve until limit
        top_sum = 0
        top_index = len(fluxes_high)-1
        while top_sum < fluxes_high.sum() * (1-central_fraction)/2.:
            top_sum += fluxes_high[top_index]
            top_index -= 1

        # Need to get this into real time...  How?
        return top_index - bottom_index

    def normalizedPeakFlux(self):
        # A measure of the peak flux normalized by constant flux,
        # like this: (Fpeak - Fconst)/(Fpeak + Fconst).
        # i.e., a doubling of flux gives normalizedPeakFlux = 0.5.
        # i.e., the appearance of a new source gives value 1.0.
        fluxes = numpy.array([])
        for src in self.objects:
            fluxes = numpy.append(fluxes, [det.peak for det in src.objects])

        # Get clipped lightcurve.  Is this correct syntax?
        # "Event" defined as all integrations with >3sigma flux
        sigmaClip = getattr(self, sigmaClip)()
        fluxes_low = fluxes[where(fluxes < fluxes.mean()+3*sigmaClip)]

        flux_const = fluxes_low.mean()
        flux_peak = fluxes.max()

        return (flux_peak - flux_const)/(flux_peak + flux_const)

    def timeIntegratedFlux(self):
        # "Integrated" flux of event by summing lightcurve during event.
        fluxes = numpy.array([])
        for src in self.objects:
            fluxes = numpy.append(fluxes, [det.peak for det in src.objects])

        # Get 3*sigma part of lightcurve.  Is this correct syntax?
        # "Event" defined as all integrations with >3sigma flux
        sigmaClip = getattr(self, sigmaClip)()
        fluxes_high = fluxes[where(fluxes >= fluxes.mean()+3*sigmaClip)]

        return fluxes_high.sum()

class Classifier(object):
    # Wrap a pymori classifier for convenient pipeline use.
    def __init__(self, trainingCurves, features=settings.featureVector):
        self.features = features
        self.idcounter = 0

        trainingData = [lc.featureVector for lc in trainingCurves]
        # need to add unique IDs for training
        for vector in trainingData:
            vector[-3] = self.idcounter
            self.idcounter += 1

        numClasses = len(classDefinitions)
        # The extra 'slot' is for units; we're not currently using it.
        axisDescription = [(name, "") for name in self.features]

        self.classifier = pymori.user.RF_RC(trainingData, 
            len(classDefinitions), 
            axis_desc=axisDescription,
            class_desc=classDefinitions)

    def classify(self, lightcurve):
        # run the wrapped classifier with the incoming lightcurve.
        # self.classifier.classify(lightcurve.featureVector(self.features))
        self.classifier.run(lightcurve.featureVector)
        
