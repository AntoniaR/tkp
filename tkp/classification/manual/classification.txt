Added classification by branches.

The classification schemes now includes branching by parameter,
instead of going through all the sources. As an example, the
classification scheme is branched on the shape of the source:
point-like or not.

This uses a <test>, with a <condition> that compares the 'shape'
attribute of the 'source' (the latter being the <type> of the
condition, and thus the main variable) to possible values. In this
case, the only <value> to be compared with is 'point', and the
condition tests whether this string is equal to the attribute of
'source'.

The <outcome> decides which branching scheme to pick. If the outcome
of the comparison is 'true' or a 'special' 'N/A' value (Not Available;
cf None in Python, or NULL in C), the <action> to be taken is a
<branch>, which then tests for all possible point-source transients.

If <outcome> is 'false', nothing happens, because the inner section of
<branch> is emtpy: there are no <classification> sections inside the <action>.

Instead of classifying directly on sources inside a branch, it is of
course entirely possible to have branches within branches. It also
possible to have branches inside a classification section, although in
general is less common.

A further extension could be to have the various classification
sections separately, each identified by a unique ID. Several
classification sections could then appear in multiple branches. This
is useful for the cases where a few sources can be found in multiple
branches (for example, AGN could be either point sources or extended
sources).

Such separately defined classification sections could be defined
inside a branch (and then be referred to from a completely other
branch), or entirey separate, outside the
<transient-classification-scheme> root. This would require some
thought how an XML style sheet or DTD would look like for such a
flexible format.
